# Глава 7. Поддержка.Формат

[Поддержка формата](http://www.boost.org/doc/libs/1_62_0/libs/format/) предлагает замену функции <std::printf().> <std::printf()>, взятой  
из стандарта си и позволяет форматировать вывод данных. Однако, она является ни
типизированной, ни расширяемой.Поддержка.формат обеспечивает безопасность типов и расширяемую альтернативу.

Поддержка.формат предоставляет класс, называющийся <boost::format>, который определен в `boost/format.hpp`.   
Схожа со  <std::printf()>, строка, содержащая специальные символы для управления форматированием, передается   
в конструктор  <boost::format>. Данные, замещающие эти специальные символы в  
выходных данных, связаны с помощью оператора <operator%>.
```
Пример 7.1. Форматированный вывод с <boost::format>
```
`#include <boost/format.hpp>`  
`#include <iostream>`  
<int> main()  
{  
  <std::cout> << boost::format{"%1%.%2%.%3%"} % 12 % 5 % 2014 << '\n';  
}  

---
Строка формата Поддержка.формат использует номера, помещенные между двумя знаками процента в качестве заполнителей
для фактических данных, которые будут связаны с использованием <operator%>.
[Пример 7.1](http://theboostcpplibraries.com/boost.format#ex.format_01/ "Пример 7.1 Форматированный вывод с boost::format") создает строку даты в виде 12.5.2014 , используя номера  12, 5 и 2014 в качестве данных. Для того, чтобы месяц появлялся перед днем, как используется в Соединённых штатах Америки, заполнители могут поменяться местами.
[Пример 7.2](http://theboostcpplibraries.com/boost.format#ex.format_02/ "Пример 7.2 Номерные заполнители с помощью boost::format") делает это изменение, отображая как 5/12/2014  
```
Пример 7.2. Номерные заполнители с помощью <boost::format> 
```
`#include <boost/format.hpp>`  
`#include <iostream>`  

<int> main()  
{  
  <std::cout> << boost::format{"%2%/%1%/%3%"} % 12 % 5 % 2014 << '\n';  
}  

---
Для форматирования данных с помощью манипуляторов, Поддержка.формат предоставляет функцию,называемую   
<boost::io::group().>
```
Пример 7.3: Использование манипуляторов с  <boost::io::group()>
```
`#include <boost/format.hpp>`  
`#include <iostream>`

<int> main()  
{  
  <std::cout> << boost::format{"%1% %2% %1%"} %  
    boost::io::group(<std>::showpos, 1) % 2 << '\n';  
}

---
[Пример 7.3](http://theboostcpplibraries.com/boost.format#ex.format_03/ "Пример 7.3 Использование манипуляторов с boost::io::group()") использует манипулятор  <std::showpos()> для значения, которое будет связано с "% 1%.Таким образом, этот пример будет отображать +1 2 +1 в качестве вывода.  
Поскольку манипулятор <std::showpos()>  был связан с первым значением данных с использованием <boost::io::group()> знак плюс автоматически добавляется всякий раз, когда отображается это значение.В этом случае формат заполнитель "% 1%"  
используется дважды.  

Если знак плюс должен быть показан только для первого выхода 1, формат заполнитель должен быть изменен.  
```
Пример 7.4. Заполнители со специальными символами
```
`#include <boost/format.hpp>`  
`#include <iostream>` 

<int> main()  
{  
  <std::cout> << boost::format{"%|1$+| %2% %1%"} % 1 % 2 << '\n';  
}

---
[Пример 7.4](http://theboostcpplibraries.com/boost.format#ex.format_04/ "Пример 7.4 Заполнители со специальными символами" ) делает это.В этом примере первый экземпляр заполнителя "%1%" заменяется на "%1$|+|".Настройка формата не просто добавляет два дополнительных знака для труб.  
Ссылка на данные также помещена между знаками труб и использует "1 $" вместо "1%". 
Это требуется для модифицирования выхода, чтобы было +1 2 1. Вы можете найти подробную информацию о спецификации формата  
в [документации поддержки](http://www.boost.org/doc/libs/1_62_0/libs/format/doc/format.html#printf_directives).

Ссылки на заполнители данных должны быть указаны или для всех заполнителей или не для кого.
```
Пример 7.5. <boost::io::format_error> в случае ошибки
```
`#include <boost/format.hpp>` 
`#include <iostream>`  

<int> main()  
{  
  <try>  
  {  
    <std::cout> << boost::format{"%|+| %2% %1%"} % 1 % 2 << '\n';  
  }  
  <catch> (boost::io::format_error &ex)  
  {  
    <std::cout> << ex.what() << '\n';  
  }  
}  

---
[Пример 7.5](http://theboostcpplibraries.com/boost.format#ex.format_05/ "Пример 7.5 boost::io::format_error в случае ошибки") генерирует исключение типа <boost::io::format_error.>  
Cтрого говоря, Поддержка.формат генерирует <boost::io::bad_format_string.>Однако,так как различные классы исключений являются  
производными от <boost::io::format_error>,обычно поймать исключения этого типа проще.  

[Пример 7.6](http://theboostcpplibraries.com/boost.format#ex.format_06/ "Пример 7.6 Заполнители без номеров") показывает, как написать программу без использования ссылок в формате строки.
```
Пример 7.6. Заполнители без номеров
```
`#include <boost/format.hpp>`  
`#include <iostream>`  

int main()  
{  
  std::cout << boost::format{"%|+| %|| %||"} % 1 % 2 % 1 << '\n';  
}  

---
Знаки трубы для второго и третьего заполнителя можно безопасно опустить в данном случае,потому что  
они не указывают формат.Полученный синтаксис чем то напоминает std::printf() 
(смотри [Пример 7.7](http://theboostcpplibraries.com/boost.format#ex.format_07/ "Пример 7.7 boost::format c синтаксисом, используемым из std::printf()").
```
Пример 7.7. <boost::format c синтаксисом>, используемым из <std::printf()>
```
`#include <boost/format.hpp>`  
`#include <iostream>`  

<int> main()  
{  
  <std::cout> << boost::format{"%+d %d %d"} % 1 % 2 % 1 << '\n';  
} 

---
Пока формат может выглядеть как тот, что используется <std::printf()>,Поддержка.формат обеспечивает преимущество безопасности типов. Буква "d" в формате строки не указывает на вывод числа. Вместо этого он применяет манипулятор <std::dec()> на внутренний объект потока, используемый форматом Поддержка.формат.Это делает возможным указывать строки формата,что не имело бы никакого смысла для <std::printf()> и может привести к аварии.
```
 Пример 7.8. <boost::format> с, казалось бы, недействительными заполнителями
```
`#include <boost/format.hpp>`  
`#include <iostream>`  

<int> main()  
{  
  <std::cout> << boost::format{"%+s %s %s"} % 1 % 2 % 1 << '\n';  
}

---
<std::printf()> допускает букву 's' только для строк типа <const char*>. С <std::printf()>, сочетание "%S" и числовое значение потерпит неудачу.Тем не менее, [пример 7.8](http://theboostcpplibraries.com/boost.format#ex.format_08/ "Пример 7.8 boost::format с, казалось бы, недействительными заполнителями") работает отлично.  
Поддержка.формат не требует строки. Вместо этого он применяет соответствующие манипуляторы  
для настройки внутреннего потока.

Поддержка.формат является и безопасным, и расширяемым типом.Объекты любого типа могут быть использованы с Поддержка.формат до тех пор, пока оператор <operator<<> перегружен для <std::ostream>.
```
Пример 7.9.<boost::format> с определяемым пользовательским типом
````
`#include <boost/format.hpp>`  
`#include <string>`  
`#include <iostream>`  

struct animal  
{  
  <std::string> name;  
  <int> legs;  
};

<std>::ostream &<operator><<(<std>::ostream &os, <const> animal &a)  
{  
  return os << a.name << ',' << a.legs;  
}

<int> main()  
{  
  animal a{"cat", 4};  
  <std::cout> << boost::format{"%1%"} % a << '\n';  
}

---
[Пример 7.9](http://theboostcpplibraries.com/boost.format#ex.format_09/ "Пример 7.9 boost::format с определяемым пользовательским типом") использует <boost::format> для записи объекта определяемого пользователем <animal> для 
стандартного вывода. Это возможно, потому что оператор потока перегружен для класса <animal>.
