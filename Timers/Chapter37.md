#Глава 37. Boost.Chrono
Библиотека [Boost.Chrono](http://www.boost.org/doc/libs/1_62_0/doc/html/chrono.html) предоставляет часы. Например, вы можете получить текущее время или измерить время, прошедшее за какой-либо процесс. 

Части Boost.Chrono были добавлены в C++11. Если ваша среда разработки поддерживает C++11, то у вас есть доступ к часам, определенным в файле заголовка `chrono`. Тем не менее, C++11 не поддерживает некоторые функции, например, часы для измерения времени центрального процессора. Кроме того, только Boost.Chrono поддерживает определяемый пользователем формат вывода времени. 

У вас есть доступ ко всем часами Boost.Chrono, используя заголовочный файл `boost/chrono.hpp`. Форматирование, требующее заголовочный файл `boost/chrono_io.hpp` - единственное расширение, которое определяется пользователем.

<a name="Example37.1"></a>
**Пример 37.1. Все часы в Boost.Chrono**
```cpp

#include <boost/chrono.hpp>
#include <iostream>

using namespace boost::chrono;

int main()
{
  std::cout << system_clock::now() << '\n';
#ifdef BOOST_CHRONO_HAS_CLOCK_STEADY
  std::cout << steady_clock::now() << '\n';
#endif
  std::cout << high_resolution_clock::now() << '\n';

#ifdef BOOST_CHRONO_HAS_PROCESS_CLOCKS
  std::cout << process_real_cpu_clock::now() << '\n';
  std::cout << process_user_cpu_clock::now() << '\n';
  std::cout << process_system_cpu_clock::now() << '\n';
  std::cout << process_cpu_clock::now() << '\n';
#endif

#ifdef BOOST_CHRONO_HAS_THREAD_CLOCK
  std::cout << thread_clock::now() << '\n';
#endif
}
```

[Пример 37.1](#Example37.1) выводит все вариации часов, представленных в Boost.Chrono. Все часы имеют общую функцию-член `now()`, которая возвращает временную точку. Все временные точки относятся к универсальному моменту времени. Эта временная точка является эпохой. Эпоха начинается с 1 января 1970. [Пример 37.1](#Example37.1) выводит эпоху для каждой временной точки.

Boost.Chrono включает в себя следующие часы:

* `boost::chrono::system_clock` возвращает системное время. Это время, как правило, отображается на рабочем столе вашего компьютера. Если вы измените время на вашем компьютере, `boost::chrono::system_clock` вернет новое время. [Пример 37.1](#Example37.1) записывает строку в стандартный вывод, который выглядит следующим образом: **13919594042183544 секунд начиная с 1 января 1970 года**.

    Эпоха не нормируется для `boost::chrono::system_clock` Эпоха 1 января 1970, которая используется в этих примерах, зависит от конкретной реализации. Однако, если вы и правда хотите получить время с 1 января 1970 вызовите `to_time_t()`. `to_time_t()` статическая функция-член, которая возвращает текущее системное время, как количество секунд, прошедших с 1 января 1970 года, как `std::time_t`. 
    
* `boost::chrono::steady_clock` это часы, которые всегда возвращают более позднее время, чем время начала работы. Даже если время устанавливается  компьюторе, `boost::chrono::steady_clock` вернет более позднее время. Это время известно, как монотонное время.

    [Пример 37.1](#Example37.1) отображает количество наносекунд, так как система была загружена. Сообщение выглядит следующим образом: **10594369282958 наносекунд с момента загрузки**. `boost::chrono::steady_clock` измеряет время, прошедшее с момента последней загрузки. Однако, начало измерения с последней загрузки, является лишь одной реализацией. Контрольная точка может изменитсья при другой реализации.
    
    `boost::chrono::steady_clock` не поддерживается на всех платформах. Часы доступны только если определен макрос `BOOST_CHRONO_HAS_CLOCK_STEADY`.
    
* `boost::chrono::high_resolution_clock` является определением типа `boost::chrono::system_clock` или `boost::chrono::steady_clock`,
в зависимости от которых время измеряется с определенной точностью. Таким образом, вывод идентичен выводу часов в `boost::chrono::high_resolution_clock`, на котором он основан.

* `boost::chrono::process_real_cpu_clock` возвращает процессорное время с момента запуска. Часы начинают работу с момента запуска программы. [Пример 37.1](#Example37.1) описывает строку в стандартный вывод, который выглядит следующим образом: **1000000 наносекунд c момента запуска**. 

    Вы также можете получить это время, используя `std::clock()` из `ctime`. На самом деле, текущая реализация `boost::chrono::process_real_cpu_clock` основана на `std::clock()`. Часы `boost::chrono::process_real_cpu_clock` и другие часы, измеряющие время центрального процессора, могут функционировать, только если определен макрос `BOOST_CHRONO_HAS_PROCESS_CLOCKS`. 
    
* `boost::chrono::process_user_cpu_clock` возвращает только время, потраченное на работу в *режиме пользователя*. Режим пользователя относится к коду, который работает отдельно от функций операционной системы. Время, необходимое для выполнения кода в операционной системе функций, вызываемых программой, не учитывается, как время режима пользователя.

    `boost::chrono::process_user_cpu_clock` возвращает только то время, котороме было проведено в пользовательском пространстве. Если программа остановлена на некоторое время, например, с помощью функции Windows `Sleep()`, время проведенное в `Sleep()`не будет учитываться. 
    
    [Пример 37.1](#Example37.1) записывает строку в стандартный вывод, который выглядит следующим образом: **15600100 наносекунд, с момента запуска процесса**
    
* `boost::chrono::process_system_cpu_clock` похож на `boost::chrono::process_user_cpu_clock`. Однако, эти часы измеряют время, проведенное в режиме *ядра*. `boost::chrono::process_system_cpu_clock` возвращает процессорное время, затраченное на исполнение функций операционной системы.

    [Пример 37.1](#Example37.1) записывает строку в стандартный вывод, который выглядит следующим образом: **0 наносекунд, с момента запуска**. Так как в этом пример не вызываются, непосредственно, функции операционной системы и, Boost.Chrono использует только несколько функций операционной системы, `boost::chrono::process_system_cpu_clock` возвращает 0.
    
* `boost::chrono::process_cpu_clock` возвращает время исполнения потока. Время измеряемое `boost::chrono::thread_clock` сравнимо с процессорным временем, за исключением того, что оно проходит в потоке, а не в процессе. `boost::chrono::thread_clock` возвращает процессорное время с момента запуска потока. Он не различает время, затраченное на пользователя и в режиме ядра. 

    boost::chrono::thread_clock не поддерживает все платформы, вы можете использовать `boost::chrono::thread_clock`, только если макрос `BOOST_CHRONO_HAS_THREAD_CLOCK` определен. Boost.Chrono обеспечивает макрос, `BOOST_CHRONO_THREAD_CLOCK_IS_STEADY`, чтобы определить, является ли `boost::chrono::thread_clock` мерой монотонности времени, как `boost::chrono::steady_clock`.
    
    [Пример 37.1](#Example37.1) записывает строку в стандартный вывод, который выглядит следующим образом: **15600100 наносекунд, начиная с заупска потока**. 
    
Все часы в Boost.Chrono зависят от функций операционной системы; Таким образом, операционная система определяет, насколько точны и надежны возвращаемые времена.

<a name="Example37.2"></a>
**Пример 37.2. Сложение и вычитаниче продолжительности, с использованием Boost.Chrono**
```cpp

#include <boost/chrono.hpp>
#include <iostream>

using namespace boost::chrono;

int main()
{
  process_real_cpu_clock::time_point p = process_real_cpu_clock::now();
  std::cout << p << '\n';
  std::cout << p - nanoseconds{1} << '\n';
  std::cout << p + milliseconds{1} << '\n';
  std::cout << p + seconds{1} << '\n';
  std::cout << p + minutes{1} << '\n';
  std::cout << p + hours{1} << '\n';
}
```

`now()` возвращает объект типа `boost::chrono::time_point` для всех вариаций часов. Этот тип тесно связан с часами, так как временные точки измеряются относительно опорной временной точки, которая определяется часами. `boost::chrono::time_point` - это шаблон, который ожидает тип часов, как параметр. Каждый тип синхронизации обеспечивает определение типа для своей специализации `boost::chrono::time_point`. Например, определением типа `process_real_cpu_clock` является `process_real_cpu_clock :: time_point`.

Boost.Chrono также предоставляет класс `boost::chrono::duration`, который описывает продолжительность временного участка. Поскольку `boost::chrono::duration` также шаблон, Boost.Chrono предоставляет шесть классов `boost::chrono::nanoseconds`, `boost::chrono::milliseconds`, `boost::chrono::microseconds`, `boost::chrono::seconds`, `boost::chrono::minutes`, и `boost::chrono::hours`, которые проще в использовании. 

Boost.Chrono перегружает несколько операторов для обработки временных промежутков и длительности. [Пример 37.2](#Example37.2) вычитает продолжительности или вычитает продолжительности из **p** чтобы получить новые временные промежутки, которые записываются в стандартный вывод. 

[Пример 37.2](#Example37.2) показывает все временные промежутки в наносекундах. Boost.Chrono автоматически использует наименьшую единицу, когда временные промежутки и длительности обрабатываются, чтобы убедиться, что результат наиболее точный. Если вы хотите использовать временные промежутки с другими единицами времени, вы должны это указать.

<a name="Example37.3"></a>
**Пример 37.3. Присвоение временных точек с использованием `boost::chrono::time_point_cast()`**
```cpp

#include <boost/chrono.hpp>
#include <iostream>

using namespace boost::chrono;

int main()
{
  process_real_cpu_clock::time_point p = process_real_cpu_clock::now();
  std::cout << p << '\n';
  std::cout << time_point_cast<minutes>(p) << '\n';
}
```

Функция `boost::chrono::time_point_cast()` используется как оператор приведения. [Пример 37.3](#Example37.3) использует `boost::chrono::time_point_cast()`, для преобразования временных промежутков, указанных в наносекундах, к временным промежуткам в минутах. В этом случае вы должны использовать `boost::chrono::time_point_cast()`, потому что временные точки не могут быть выражены в более точных еденицах(минутах), без потенциальной потери точности. Вам не требуется `boost::chrono::time_point_cast()` для преобразования менее точных едениц в более точные. 

Boost.Chrono предоставляет оператор приведения для продолжительности.

<a name="Example37.4"></a>
**Пример 37.4. Присвоение временных точек с использованием `boost::chrono::duration_cast()`**
```cpp

 #include <boost/chrono.hpp>
#include <iostream>

using namespace boost::chrono;

int main()
{
  minutes m{1};
  seconds s{35};

  std::cout << m + s << '\n';
  std::cout << duration_cast<minutes>(m + s) << '\n';
}
```

[Пример 37.4](#Example37.4) использует функцию `boost::chrono::duration_cast()` преобразует продолжительность из секунд в минуты. Этот пример записывает **1 минута** в стандартный вывод.

<a name="Example37.5"></a>
**Пример 37.5. Округление продолжительностей**
```cpp

 #include <boost/chrono.hpp>
#include <iostream>

using namespace boost::chrono;

int main()
{
  std::cout << floor<minutes>(minutes{1} + seconds{45}) << '\n';
  std::cout << round<minutes>(minutes{1} + seconds{15}) << '\n';
  std::cout << ceil<minutes>(minutes{1} + seconds{15}) << '\n';
}
```

Boost.Chrono также предоставляет функции округления продолжительностей при приведении. `boost::chrono::round()` округляет в большую или меньшую сторону, `boost::chrono::floor()` округляет в меньшую сторону и `boost::chrono::ceil()` округляет в большую сторону. `boost::chrono::floor()` использует `boost::chrono::duration_cast()` - между этими функциями нет разницы. 

[Пример 37.5](#Example37.5) выводит **1 минуту**, **1 минуту** и **2 минуты** в стандартный вывод.

<a name="Example37.6"></a>
**Пример 37.6. Потоковые манипуляторы для определенного пользователем выхода**
```cpp

#define BOOST_CHRONO_VERSION 2
#include <boost/chrono.hpp>
#include <boost/chrono/chrono_io.hpp>
#include <iostream>

using namespace boost::chrono;

int main()
{
    std::cout << symbol_format << minutes{10} << '\n';

  std::cout << time_fmt(boost::chrono::timezone::local, "%H:%M:%S") <<
    system_clock::now() << '\n';
}
 ```
 
Boost.Chrono предоставляет различные потоковые манипуляторы для форматирования вывода временных точек и длительности. Например, с манипулятором `boost::chrono::symbol_format()`, единица времени записывается как символ вместо имени. Таким образом, в [примере 37.6](#Example37.6) выводит **10 min**.

Манипулятор `boost::chrono::time_fmt()` может быть использован для установки часового пояса и формата вывода. Часовой пояс должен быть установлен на `boost::chrono::timezone::local` или `boost::chrono::timezone::utc`. Строка формата может использовать флаги для обозначения различных компонентов временных промежутков. Например, [пример 37.6](#Example37.6) выводит строку в стандартный вывод, который выглядит следующим образом:  **15:46:44**.

Помимо потоковых манипуляторов, Boost.Chrono обеспечивает грани для различных настроек. Например, есть грань, которая позволяет выводить временные промежутки на другом языке.

**Заметка**

Есть две версии функций ввода/вывода с Boost 1.52.0. Так как Boost 1.55.0, более новая версия, эти функции используются по умолчанию. Если вы используете версию старше 1.55.0, необходимо определить макрос `BOOST_CHRONO_VERSION` и установить его на 2, как в [примере 37.6](#Example37.6), для корректной работы. 
