#Глава 37. Boost.Chrono
Библиотека [Boost.Chrono](http://www.boost.org/doc/libs/1_62_0/doc/html/chrono.html) предоставляет вариации часов. Например, вы можете получить текущее время или вы можете измерить время, прошедшее в процессе. 

Части Boost.Chrono были добавлены в C++ 11. Если ваша среда разработки поддерживает C++ 11, то у вас есть доступ к нескольким часам, определенных в файле заголовка `chrono`. Тем не менее, C++ 11 не поддерживает некоторые функции, например, часы для измерения времени центрального процессора. Кроме того, только Boost.Chrono поддерживает определяемый пользователем формат вывода времени. 

У вас есть доступ ко всем часами Boost.Chrono, используя заголовочный файл `boost/chrono.hpp`. Единственной расширение, которое определяется пользователем - форматирование, которое требует заголовочного файла `boost/chrono_io.hpp`.

<a name="Example37.1"></a>
**Пример 37.1. Все часы в Boost.Chrono**

    #include <boost/chrono.hpp>
    #include <iostream>

    using namespace boost::chrono;

    int main()
    {
      std::cout << system_clock::now() << '\n';
    #ifdef BOOST_CHRONO_HAS_CLOCK_STEADY
      std::cout << steady_clock::now() << '\n';
    #endif
      std::cout << high_resolution_clock::now() << '\n';

    #ifdef BOOST_CHRONO_HAS_PROCESS_CLOCKS
      std::cout << process_real_cpu_clock::now() << '\n';
      std::cout << process_user_cpu_clock::now() << '\n';
      std::cout << process_system_cpu_clock::now() << '\n';
      std::cout << process_cpu_clock::now() << '\n';
    #endif

    #ifdef BOOST_CHRONO_HAS_THREAD_CLOCK
      std::cout << thread_clock::now() << '\n';
    #endif
    }
    
[Пример 37.1](#Example37.1) выводит все часы, представленные в Boost.Chrono. Все часы имеют общую член-функцию `now()`, которая возвращает к временной точке. Все временные точки относятся к универсальному моменту времени. Эта временная точка является эпохой. Часто используемой эпохой является 1 января 1970. [Пример 37.1](#Example37.1) выводит эпоху для каждой временной точки.

Boost.Chrono включает в себя следующие часы:

* `boost::chrono::system_clock` возвращает системное время. Это время, как правило, отображается на рабочем столе вашего компьютера. Если вы измените время на вашем компьютере, `boost::chrono::system_clock` вернет новое время. [Пример 37.1](#Example37.1) записывает строку в стандартный вывод, который выглядит следующим образом: **13919594042183544 секунд начиная с 1 января 1970 года**.

    Эпоха не нормируется для `boost::chrono::system_clock` Эпоха 1 января 1970, которая используется в этих примерах, зависит от конкретной реализации. Однако, если вы и правда хотите получить время с 1 января 1970 вызовите `to_time_t()`. `to_time_t()` статиеская член-функция, которая возвращает текущее системное время, как количество секунд, прошедших с 1 января 1970 года, как `std::time_t`. 
    
* `boost::chrono::steady_clock` это часы, которые всегда будут возвращают более позднее время, чем когда они начали работу. Даже если время устанавливается на компьюторе, `boost::chrono::steady_clock` вернет более позднее время. Это время известно, как монотонное время.

    [Пример 37.1](#Example37.1) отображает количество наносекунд, так как система была загружена. Сообщение выглядит следующим образом: **10594369282958 наносекунд с момента загрузки**. `boost::chrono::steady_clock` измеряет время, прошедшее с момента последней загрузки. Однако, начало измерения с последней загрузки, является лишь одной реализацией. Контрольная точка может изменитсья при другой реализации.
    
    `boost::chrono::steady_clock` не поддерживается на всех платформах. Часы доступны только если макрос `BOOST_CHRONO_HAS_CLOCK_STEADY` определен.
    
* `boost::chrono::high_resolution_clock` является определением типа `boost::chrono::system_clock` или `boost::chrono::steady_clock`
В зависимости от которых время измеряется с определенной точностью. Таким образом, выходной сигнал идентичен выходу часов `boost::chrono::high_resolution_clock`, на которых он основан.

* `boost::chrono::process_real_cpu_clock` возвращает процессорное время с момента запуска. Часы начинают работу с момента запуска программы. [Пример 37.1](#Example37.1) аписывает строку в стандартный вывод, который выглядит следующим образом: **1000000 наносекунд c момента запуска**. 

    Вы также можете получить это время, используя `std::clock()` из `ctime`. На самом деле, текущая реализация `boost::chrono::process_real_cpu_clock` основана на `std::clock()`. Часы `boost::chrono::process_real_cpu_clock` и другие часы, измеряющие время центрального процессора, могут функционировать, только если определен макрос `BOOST_CHRONO_HAS_PROCESS_CLOCKS`. 
    
* `boost::chrono::process_user_cpu_clock` возвращает только время, потраченное на работу в *пользовательском пространстве*. Пользовательское пространство относится к коду, который работает отдельно от функций операционной системы. Время, необходимое для выполнения кода в операционной системе функций, вызываемых программой, не учитывается, как время пользовательского пространства.

    `boost::chrono::process_user_cpu_clock` возвращает только то время, котороме было проведено в пользовательском пространстве. Если программа остановлена на некоторое время, например, с помощью функции Windows `Sleep()`, время проведенное в `Sleep()`не будет учитываться. 
    
    [Пример 37.1](#Example37.1) записывает строку в стандартный вывод, который выглядит следующим образом: **15600100 наносекунд, с момента запуска**
    
* `boost::chrono::process_system_cpu_clock` похож на `boost::chrono::process_user_cpu_clock`. Однако, эти часы измеряют время, проведенное в пространстве *ядра*. `boost::chrono::process_system_cpu_clock` возвращает процессорное время, испольняеммый функцией операционной системы.

    [Пример 37.1](#Example37.1) записывает строку в стандартный вывод, который выглядит следующим образом: **0 наносекунд, с момента запуска** Поскольку этот пример не вызывает, непосредственно, функции операционной системы и потому, что Boost.Chrono использует только несколько функций операционной системы, `boost::chrono::process_system_cpu_clock` может возвращать 0.
    
* `boost::chrono::process_cpu_clock` возвращает время исполнения потомка. Время измеряемое `boost::chrono::thread_clock` сравнимо с процессорным временем, за исключением того, что на потоке, а не на процессе. `boost::chrono::thread_clock` возвращает процессорное время с момента запуска потока. Он не различает время, затраченное на пользователя и на пространсво ядра. 

    boost::chrono::thread_clock не поддерживает все платформы, вы можете использовать `boost::chrono::thread_clock`, только если макрос `BOOST_CHRONO_HAS_THREAD_CLOCK` определен. Boost.Chrono обеспечивает макрос, `BOOST_CHRONO_THREAD_CLOCK_IS_STEADY`, чтобы определить, является ли `boost::chrono::thread_clock` мерой монотонности времени, как `boost::chrono::steady_clock`.
    
    [Пример 37.1](#Example37.1) записывает строку в стандартный вывод, который выглядит следующим образом: **15600100 наносекунд, начиная с заупска потока**. 
    
Все часы в Boost.Chrono зависят от функций операционной системы; Таким образом, операционная система определяет, насколько точны и надежны возвращаемые времена.

<a name="Example37.2"></a>
**Пример 37.2. Сложение и вычитаниче продолжительности, с использованием Boost.Chrono**

    #include <boost/chrono.hpp>
    #include <iostream>

    using namespace boost::chrono;

    int main()
    {
      process_real_cpu_clock::time_point p = process_real_cpu_clock::now();
      std::cout << p << '\n';
      std::cout << p - nanoseconds{1} << '\n';
      std::cout << p + milliseconds{1} << '\n';
      std::cout << p + seconds{1} << '\n';
      std::cout << p + minutes{1} << '\n';
      std::cout << p + hours{1} << '\n';
    }
    
`now()` возвращает объект типа `boost::chrono::time_point` для всех часов. Этот тип тесно связан с часами, так как временная точки измеряется относительно опорной временной точки, которая определяется часами. `boost::chrono::time_point` шаблон, который ожидает тип часов, как параметр. Каждый тип синхронизации обеспечивает определение типа для своей спеуциализации `boost::chrono::time_point`. Например, определение типа `process_real_cpu_clock` является `process_real_cpu_clock :: time_point`.

Boost.Chrono также предоставляет класс `boost::chrono::duration`, которая описывает продолжительность. Поскольку `boost::chrono::duration` также шаблон, Boost.Chrono предоставляет шесть классов `boost::chrono::nanoseconds`, `boost::chrono::milliseconds`, `boost::chrono::microseconds`, `boost::chrono::seconds`, `boost::chrono::minutes`, и `boost::chrono::hours`. Которые проще в использовании. 

Boost.Chrono перегружает несколько операторов для обработки временных точек и длительности. [Пример 37.2](#Example37.2) вычитает продолжительности или вычитает продолжительности из **p** чтобы получить новые моменты времени, которые записываются на стандартный вывод. 

[Пример 37.2](#Example37.2) показывает все моменты времени в наносекундах. Boost.Chrono автоматически использует наименьшую единицу, когда моменты времени и длительности обрабатываются, чтобы убедиться, что результат наиболее точный. Если вы хотите использовать временные точки с другими единицами времени, вы должны это указать.

<a name="Example37.3"></a>
**Пример 37.3. Присвоение временных точек с использованием `boost::chrono::time_point_cast()`**

    #include <boost/chrono.hpp>
    #include <iostream>

    using namespace boost::chrono;

    int main()
    {
      process_real_cpu_clock::time_point p = process_real_cpu_clock::now();
      std::cout << p << '\n';
      std::cout << time_point_cast<minutes>(p) << '\n';
    }
    
Функция `boost::chrono::time_point_cast()` используется как оператор приведения. [Пример 37.3](#Example37.3) использует `boost::chrono::time_point_cast()`, для преобразования временной точки, основанной на наносекундах, к временной точке в минутах. В этом случае вы должны использовать `boost::chrono::time_point_cast()`, потому что временные точки не могут быть выражены в более точных еденицах(минутах), без потенциальной потери точности. Вам не требуется `boost::chrono::time_point_cast()` для преобразования менее точных едениц в более точные. 

Boost.Chrono предоставляет оператор приведения для продолжительности.

<a name="Example37.4"></a>
**Пример 37.4. Присвоение временных точек с использованием `boost::chrono::duration_cast()`**

    #include <boost/chrono.hpp>
    #include <iostream>

    using namespace boost::chrono;

    int main()
    {
      minutes m{1};
      seconds s{35};

      std::cout << m + s << '\n';
      std::cout << duration_cast<minutes>(m + s) << '\n';
    }
    
[Пример 37.4](#Example37.4) использует функцию `boost::chrono::duration_cast()` приводит продолжительность от секунд к минутам. Этот пример записывает **1 минуту** в стандартный вывод.

<a name="Example37.5"></a>
**Пример 37.5. Округлени продолжительностей**

    #include <boost/chrono.hpp>
    #include <iostream>

    using namespace boost::chrono;

    int main()
    {
      std::cout << floor<minutes>(minutes{1} + seconds{45}) << '\n';
      std::cout << round<minutes>(minutes{1} + seconds{15}) << '\n';
      std::cout << ceil<minutes>(minutes{1} + seconds{15}) << '\n';
    }
    
Boost.Chrono также предоставляет функции округления продолжительностей при пиведении. `boost::chrono::round()` округляет вверх или вниз, `boost::chrono::floor()` округляет вниз и `boost::chrono::ceil()` округляет вверх. `boost::chrono::floor()` использует `boost::chrono::duration_cast()` - между этими функциями нет разницы. 

[Пример 37.5](#Example37.5) записывает **1 минуту**, **1 минуту** и **2 минуты** в стандартный вывод.

<a name="Example37.6"></a>
**Пример 37.6. Потоковые манипуляторы для определенного пользователем выхода**

    #define BOOST_CHRONO_VERSION 2
    #include <boost/chrono.hpp>
    #include <boost/chrono/chrono_io.hpp>
    #include <iostream>

    using namespace boost::chrono;

    int main()
    {
      std::cout << symbol_format << minutes{10} << '\n';

      std::cout << time_fmt(boost::chrono::timezone::local, "%H:%M:%S") <<
        system_clock::now() << '\n';
    }
    
Boost.Chrono предоставляет различные потоковые манипуляторы для форматирования вывода временных точек и длительности. Например, с манипулятором `boost::chrono::symbol_format()`, единица времени записывается как символ вместо имени. Таким образом, в [примере 37.6](#Example37.6) выводит **10 минут**.

Манипулятор `boost::chrono::time_fmt()` может быть использован для установки часового пояса и формата строки. Часовой пояс должен быть установлен на `boost::chrono::timezone::local` или `boost::chrono::timezone::utc`. Строка формата может использовать флаги для обозначения различных компонентов временной точки. Например, [пример 37.6](#Example37.6) записывает строку в стандартный вывод, который выглядит следующим образом:  **15:46:44**.

Помимо потоковых манипуляторов, Boost.Chrono обеспечивает аспекты для многих различных настроек. Например, есть аспект, который позволяет выводить временные точки на другом языке.

**Заметка**

Есть два варианта функций ввода/вывода с Boost 1.52.0. Так как Boost 1.55.0, более новая версия, эти функции используются по умолчанию. Если вы используете версию старше 1.55.0, необходимо определить макрос `BOOST_CHRONO_VERSION` и установить его на 2, как в [пример 37.6](#Example37.6), для корректной работы. 
